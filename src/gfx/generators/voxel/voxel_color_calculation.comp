#version 460

#include "globals.glsl"
#include "intersectables.glsl"

layout(local_size_x = 32, local_size_y = 32) in;

layout(set = 0, binding = 2, rgba32f) uniform image2D visible_voxel_image[];

layout(push_constant) uniform PushConstants
{
    uint face_hash_map_offset;
    uint visible_voxel_image_offset;
}
in_push_constants;

#define BRICK_MAPS_OFFSET        0
#define LIGHT_BUFFER_OFFSET      1
#define VISIBILITY_BRICKS_OFFSET 2
#define MATERIAL_BRICKS_OFFSET   3
#define VOXEL_MATERIALS_OFFSET   4
#define VOXEL_HASH_MAP_OFFSET    in_push_constants.visible_voxel_image_offset

#include "misc.glsl"
#include "voxel_faces.glsl"
#include "voxel_tracing.glsl"

void main()
{
    const ivec2 thisPixel = ivec2(gl_GlobalInvocationID.xy);

    if (all(lessThan(thisPixel, GlobalData.framebuffer_size)))
    {
        const vec4 rawPixelData =
            imageLoad(visible_voxel_image[in_push_constants.visible_voxel_image_offset], thisPixel);
        const vec3 worldStrikePosition = rawPixelData.xyz;
        const u32  uniqueFaceId        = floatBitsToUint(rawPixelData.w);

        UnpackUniqueFaceIdResult unpacked = unpackUniqueFaceId(uniqueFaceId);

        const uvec3 bC = unpacked.position_in_chunk / 8;
        const uvec3 bP = unpacked.position_in_chunk % 8;

        const vec3 box_corner_negative = vec3(-16.0f); // TODO: fix

        const PBRVoxelMaterial material = getMaterialFromPosition(
            in_global_chunk_bricks[BRICK_MAPS_OFFSET].storage[unpacked.chunk_id].data[bC.x][bC.y][bC.z], bP);

        const u32 startSlot = gpu_hashU32(uniqueFaceId) % kHashTableCapacity;

        for (uint i = 0; i < 32; ++i)
        {
            const u32 thisSlot = (startSlot + i) % kHashTableCapacity;

            const u32 prev = atomicCompSwap(in_voxel_hash_map[5].nodes[thisSlot].key, kEmpty, uniqueFaceId);

            if (prev == kEmpty || prev == uniqueFaceId)
            {
                const GpuRaytracedLight light = in_raytraced_lights[1].lights[0];

                vec3 calculatedColor = calculatePixelColor(
                    worldStrikePosition,
                    unpacked.normal,
                    normalize(GlobalData.camera_position.xyz - worldStrikePosition),
                    normalize(light.position_and_half_intensity_distance.xyz - worldStrikePosition),
                    light.position_and_half_intensity_distance.xyz,
                    light.color_and_power.xyz,
                    material.albedo_roughness.xyz,
                    material.emission_metallic.w,
                    material.albedo_roughness.w,
                    light.color_and_power.w,
                    light.position_and_half_intensity_distance.w);

                const VoxelTraceResult shadowResult = traceDDARay(
                    0,
                    worldStrikePosition - box_corner_negative + 0.05 * unpacked.normal,
                    light.position_and_half_intensity_distance.xyz - box_corner_negative);

                if (shadowResult.intersect_occur)
                {
                    calculatedColor = vec3(0);
                }

                atomicAdd(in_voxel_hash_map[5].nodes[thisSlot].r_1024, uint(calculatedColor.x * 1024));
                atomicAdd(in_voxel_hash_map[5].nodes[thisSlot].g_1024, uint(calculatedColor.y * 1024));
                atomicAdd(in_voxel_hash_map[5].nodes[thisSlot].b_1024, uint(calculatedColor.z * 1024));
                atomicAdd(in_voxel_hash_map[5].nodes[thisSlot].samples, 1);

                if (prev == kEmpty)
                {
                    atomicAdd(in_voxel_hash_map[5].nodes[thisSlot].r_1024, 1);
                    atomicAdd(in_voxel_hash_map[5].nodes[thisSlot].g_1024, 1);
                    atomicAdd(in_voxel_hash_map[5].nodes[thisSlot].b_1024, 1);
                    atomicAdd(in_voxel_hash_map[5].nodes[thisSlot].samples, 1);
                }

                // in_voxel_hash_map[5].nodes[thisSlot].r_1024 = packUnorm4x8(vec4(calculatedColor, 1.0));
                break;
            }
        }
    }
}