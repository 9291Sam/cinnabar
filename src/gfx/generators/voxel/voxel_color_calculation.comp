#version 460

#include "globals.glsl"
#include "intersectables.glsl"

layout(local_size_x = 32, local_size_y = 32) in;

layout(set = 0, binding = 2, rgba32f) uniform image2D visible_voxel_image[];

layout(push_constant) uniform PushConstants
{
    uint face_hash_map_offset;
    uint visible_voxel_image_offset;
}
in_push_constants;

#define BRICK_MAPS_OFFSET        0
#define LIGHT_BUFFER_OFFSET      1
#define VISIBILITY_BRICKS_OFFSET 2
#define MATERIAL_BRICKS_OFFSET   3
#define VOXEL_MATERIALS_OFFSET   4
#define VOXEL_HASH_MAP_OFFSET    in_push_constants.visible_voxel_image_offset

#include "misc.glsl"
#include "voxel_faces.glsl"
#include "voxel_tracing.glsl"

VoxelTraceResult traceSingleRayInChunk(Ray ray, float dist)
{
    return traceDDARay(0, ray.origin, ray.origin + ray.direction * dist);
}

// PCG (permuted congruential generator). Thanks to:
// www.pcg-random.org and www.shadertoy.com/view/XlGcRh
uint NextRandom(inout uint state)
{
    state       = state * 747796405 + 2891336453;
    uint result = ((state >> ((state >> 28) + 4)) ^ state) * 277803737;
    result      = (result >> 22) ^ result;
    return result;
}

float RandomValue(inout uint state)
{
    return NextRandom(state) / 4294967295.0; // 2^32 - 1
}

// Random value in normal distribution (with mean=0 and sd=1)
float RandomValueNormalDistribution(inout uint state)
{
    // Thanks to https://stackoverflow.com/a/6178290
    float theta = 2 * 3.1415926 * RandomValue(state);
    float rho   = sqrt(-2 * log(RandomValue(state)));
    return rho * cos(theta);
}

// Calculate a random direction
vec3 RandomDirection(inout uint state)
{
    // Thanks to https://math.stackexchange.com/a/1585996
    float x = RandomValueNormalDistribution(state);
    float y = RandomValueNormalDistribution(state);
    float z = RandomValueNormalDistribution(state);
    return normalize(vec3(x, y, z));
}

vec3 RandomHemisphericalDirection(vec3 normal, inout uint rngState)
{
    vec3 dir = RandomDirection(rngState);

    return dir * sign(dot(normal, dir));
}

vec3 calculateColor(
    vec3 chunkStrikePosition, PBRVoxelMaterial firstMaterial, UnpackUniqueFaceIdResult unpacked, uint rngState)
{
    // return vec3(0);
    // vec3 incomingLight = vec3(0.0);
    // vec3 rayColor      = vec3(firstMaterial.albedo_roughness.xyz);
    // Ray  ray;
    // ray.origin    = chunkStrikePosition + 0.05 * unpacked.normal;
    // ray.direction = RandomHemisphericalDirection(unpacked.normal, rngState);

    // const u32 maxBounceCount = 3;

    // for (int i = 0; i < maxBounceCount; ++i)
    // {
    //     VoxelTraceResult traceResult = traceSingleRayInChunk(ray, 96.0);

    //     if (traceResult.intersect_occur)
    //     {
    //         ray.origin    = traceResult.chunk_local_fragment_position + 0.05 * traceResult.voxel_normal;
    //         ray.direction = RandomHemisphericalDirection(traceResult.voxel_normal, rngState);

    //         const PBRVoxelMaterial material     = traceResult.material;
    //         const vec3             emittedLight = material.emission_metallic.xyz;
    //         incomingLight += emittedLight * rayColor;
    //         rayColor *= (material.albedo_roughness.xyz);
    //     }
    //     else
    //     {
    //         break;
    //     }
    // }

    // return incomingLight;

    // return firstMaterial.albedo_roughness.xyz;
    // return firstMaterial.albedo_roughness.xyz;
    const GpuRaytracedLight light = in_raytraced_lights[1].lights[0];

    const vec3 worldStrikePosition = chunkStrikePosition + vec3(-16.0);

    vec3 lightColor = calculatePixelColor(
        worldStrikePosition,
        unpacked.normal,
        normalize(GlobalData.camera_position.xyz - worldStrikePosition),
        normalize(light.position_and_half_intensity_distance.xyz - worldStrikePosition),
        light,
        firstMaterial,
        true,
        true);

    const VoxelTraceResult shadowResult = traceDDARay(
        0, chunkStrikePosition + 0.05 * unpacked.normal, light.position_and_half_intensity_distance.xyz - vec3(-16.0));

    vec3 calculatedColor = vec3(0.0);

    if (!shadowResult.intersect_occur)
    {
        calculatedColor += lightColor;
        // calculatedColor *=
        // calculatedColor = 1 - calculatedColor;
    }

    // const Ray giRay =
    //     Ray(chunkStrikePosition + 0.05 * unpacked.normal, normalize(unpacked.normal + RandomDirection(rngState)));

    // const VoxelTraceResult giResult = traceSingleRayInChunk(giRay, 64.0f);

    // vec3 giColor = vec3(0);

    // if (giResult.intersect_occur)
    // {
    //     giColor = calculatePixelColor(
    //                   giResult.chunk_local_fragment_position + vec3(-16.0),
    //                   giResult.voxel_normal,
    //                   normalize(giRay.origin - giResult.chunk_local_fragment_position),
    //                   normalize(
    //                       light.position_and_half_intensity_distance.xyz - giResult.chunk_local_fragment_position
    //                       + vec3(-16.0)),
    //                   light,
    //                   firstMaterial,
    //                   false,
    //                   true)
    //             * firstMaterial.albedo_roughness.xyz;
    // }

    // calculatedColor += giColor;

    return calculatedColor;
}

#define atomicHalve(mem)                                                                                               \
    {                                                                                                                  \
        while (true)                                                                                                   \
        {                                                                                                              \
            const u32 desiredMem  = mem;                                                                               \
            const u32 desiredHalf = mem / 2;                                                                           \
                                                                                                                       \
            const u32 actualPrevMem = atomicCompSwap(mem, desiredMem, desiredHalf);                                    \
                                                                                                                       \
            if (actualPrevMem == desiredMem)                                                                           \
            {                                                                                                          \
                break;                                                                                                 \
            }                                                                                                          \
        }                                                                                                              \
    }

void main()
{
    const vec3  box_corner_negative = vec3(-16.0f); // TODO: fix
    const ivec2 thisPixel           = ivec2(gl_GlobalInvocationID.xy);

    if (all(lessThan(thisPixel, GlobalData.framebuffer_size)))
    {
        const vec4 rawPixelData =
            imageLoad(visible_voxel_image[in_push_constants.visible_voxel_image_offset], thisPixel);
        const vec3 worldStrikePosition = rawPixelData.xyz;
        const vec3 chunkStrikePosition = worldStrikePosition - box_corner_negative;
        const u32  uniqueFaceId        = floatBitsToUint(rawPixelData.w);

        UnpackUniqueFaceIdResult unpacked = unpackUniqueFaceId(uniqueFaceId);

        const uvec3 bC = unpacked.position_in_chunk / 8;
        const uvec3 bP = unpacked.position_in_chunk % 8;

        const PBRVoxelMaterial material = getMaterialFromPosition(
            in_global_chunk_bricks[BRICK_MAPS_OFFSET].storage[unpacked.chunk_id].data[bC.x][bC.y][bC.z], bP);

        const u32 startSlot = gpu_hashU32(uniqueFaceId) % kHashTableCapacity;

        for (uint i = 0; i < 32; ++i)
        {
            const u32 thisSlot = (startSlot + i) % kHashTableCapacity;

            const u32 prev = atomicCompSwap(in_voxel_hash_map[5].nodes[thisSlot].key, kEmpty, uniqueFaceId);

            // if (prev == uniqueFaceId)
            // {
            //     break;
            // }

            if (prev == kEmpty || prev == uniqueFaceId)
            {
                u32 rngState = gpu_hashCombineU32(
                    gpu_hashU32(uniqueFaceId),
                    floatBitsToUint(GlobalData.time_alive) + gl_GlobalInvocationID.x + 872347
                        + gl_GlobalInvocationID.y * 4444);

                const vec3 calculatedColor = calculateColor(chunkStrikePosition, material, unpacked, rngState);

                atomicAdd(in_voxel_hash_map[5].nodes[thisSlot].r_1024, uint(calculatedColor.x * 1024));
                atomicAdd(in_voxel_hash_map[5].nodes[thisSlot].g_1024, uint(calculatedColor.y * 1024));
                atomicAdd(in_voxel_hash_map[5].nodes[thisSlot].b_1024, uint(calculatedColor.z * 1024));
                atomicAdd(in_voxel_hash_map[5].nodes[thisSlot].samples, 1);

                if (prev == kEmpty)
                {
                    atomicAdd(in_voxel_hash_map[5].nodes[thisSlot].r_1024, 1);
                    atomicAdd(in_voxel_hash_map[5].nodes[thisSlot].g_1024, 1);
                    atomicAdd(in_voxel_hash_map[5].nodes[thisSlot].b_1024, 1);
                    atomicAdd(in_voxel_hash_map[5].nodes[thisSlot].samples, 1);
                }

                // if (rngState % 1024 == 0)
                // {
                //     atomicHalve(in_voxel_hash_map[5].nodes[thisSlot].r_1024);
                //     atomicHalve(in_voxel_hash_map[5].nodes[thisSlot].g_1024);
                //     atomicHalve(in_voxel_hash_map[5].nodes[thisSlot].b_1024);
                //     atomicHalve(in_voxel_hash_map[5].nodes[thisSlot].samples);
                // }

                break;
            }
        }
    }
}